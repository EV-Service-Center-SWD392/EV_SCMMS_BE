using EV_SCMMS.Core.Application.DTOs.WorkOrder;
using EV_SCMMS.Core.Application.Interfaces;
using EV_SCMMS.Core.Application.Interfaces.Services;
using EV_SCMMS.Core.Application.Results;
using EV_SCMMS.Core.Domain.Models;
using EV_SCMMS.Infrastructure.Mappings;
using Microsoft.EntityFrameworkCore;

namespace EV_SCMMS.Infrastructure.Services;

/// <summary>
/// Technician-driven Work Order lifecycle service (draft -> approval -> execution).
/// Entity model is not modified; state enforcement occurs at service layer.
/// </summary>
public class WorkOrderService : IWorkOrderService
{
    private static readonly HashSet<string> EditableStates = new(StringComparer.OrdinalIgnoreCase) { "DRAFT", "REVISED" };
    private readonly IUnitOfWork _unitOfWork;

    public WorkOrderService(IUnitOfWork unitOfWork)
    {
        _unitOfWork = unitOfWork;
    }

    public async Task<IServiceResult<WorkOrderDto>> CreateAsync(CreateWorkOrderDto dto, CancellationToken ct = default)
    {
        try
        {
            if (dto == null || dto.IntakeId == Guid.Empty)
            {
                return ServiceResult<WorkOrderDto>.Failure("IntakeId is required");
            }

            // Build response lines by always deriving PartName/UnitPrice from SparepartTuht
            List<WorkOrderLineDto>? responseLines = null;
            if (dto.Lines != null && dto.Lines.Any())
            {
                responseLines = new List<WorkOrderLineDto>();
                foreach (var line in dto.Lines)
                {
                    var partObj = await _unitOfWork.SparepartRepository.GetByIdAsync(line.PartId);
                    if (partObj is SparepartTuht part)
                    {
                        responseLines.Add(new WorkOrderLineDto
                        {
                            PartId = part.Sparepartid,
                            PartName = part.Name,
                            Qty = line.Qty,
                            UnitPrice = part.Unitprice,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                    else
                    {
                        responseLines.Add(new WorkOrderLineDto
                        {
                            PartId = line.PartId,
                            Qty = line.Qty,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                }
            }

            var intake = await _unitOfWork.ServiceIntakeRepository.GetAllQueryable()
                .Include(si => si.Booking)
                    .ThenInclude(b => b.Orderthaontt)
                .FirstOrDefaultAsync(si => si.Intakeid == dto.IntakeId, ct);

            if (intake == null)
            {
                return ServiceResult<WorkOrderDto>.Failure("Service intake not found");
            }

            var status = intake.Status ?? string.Empty;
            if (!status.Equals("VERIFIED", StringComparison.OrdinalIgnoreCase) && !status.Equals("FINALIZED", StringComparison.OrdinalIgnoreCase))
            {
                return ServiceResult<WorkOrderDto>.Failure("Work Order can be created only when intake is VERIFIED or FINALIZED");
            }

            var existingWorkOrder = await _unitOfWork.WorkOrderRepository.GetByIntakeAsync(dto.IntakeId, ct);
            if (existingWorkOrder != null)
            {
                return ServiceResult<WorkOrderDto>.Failure("Work order already exists for this intake");
            }

            // Ensure an Order exists for this booking and link it
            var booking = intake.Booking;
            if (booking == null)
            {
                return ServiceResult<WorkOrderDto>.Failure("Intake has no related booking");
            }

            // Load current order via booking navigation; create if missing
            var order = booking.Orderthaontt;
            if (order == null)
            {
                order = new Orderthaontt
                {
                    // Orderid will be generated by DB (uuid_generate_v4)
                    Bookingid = booking.Bookingid,
                    Customerid = booking.Customerid,
                    Vehicleid = booking.Vehicleid,
                    Status = "CREATED",
                    Isactive = true,
                    Createdat = DateTime.UtcNow,
                    Updatedat = DateTime.UtcNow,
                    Totalamount = 0m
                };
                booking.Orderthaontt = order;
                await _unitOfWork.SaveChangesAsync(ct);
            }

            var entity = dto.ToEntity();
            entity.Orderid = order.Orderid;
            entity.Status = "DRAFT";
            entity.Createdat = DateTime.UtcNow;
            entity.Updatedat = entity.Createdat;
            entity.Isactive = true;

            await _unitOfWork.WorkOrderRepository.AddAsync(entity);
            await _unitOfWork.SaveChangesAsync(ct);

            // Reload with includes for mapping
            var reloaded = await _unitOfWork.WorkOrderRepository.GetByIdAsync(entity.WoaId, ct) ?? entity;
            var dtoOut = reloaded.ToDto();
            // The following fields are not persisted; echo back from request if provided
            dtoOut.Title = dto.Title;
            dtoOut.Description = dto.Description;
            dtoOut.EstimatedAmount = dto.EstimatedAmount;
            dtoOut.Lines = responseLines;

            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Work Order created in DRAFT");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error creating Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> UpdateAsync(Guid id, UpdateWorkOrderDto dto, CancellationToken ct = default)
    {
        try
        {
            var entity = await LoadTrackedAsync(id, ct);
            if (entity == null)
            {
                return ServiceResult<WorkOrderDto>.Failure("Work Order not found");
            }

            if (!EditableStates.Contains(entity.Status ?? string.Empty))
            {
                return ServiceResult<WorkOrderDto>.Failure("Only DRAFT or REVISED Work Orders can be updated");
            }

            entity.UpdateFromDto(dto);
            await _unitOfWork.SaveChangesAsync(ct);

            var refreshed = await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct) ?? entity;
            var dtoOut = refreshed.ToDto();
            // Not persisted fields: echo input for client convenience
            dtoOut.Title = dto.Title;
            dtoOut.Description = dto.Description;
            dtoOut.EstimatedAmount = dto.EstimatedAmount;
            if (dto.Lines != null && dto.Lines.Any())
            {
                var mapped = new List<WorkOrderLineDto>();
                foreach (var line in dto.Lines)
                {
                    var partObj = await _unitOfWork.SparepartRepository.GetByIdAsync(line.PartId);
                    if (partObj is SparepartTuht part)
                    {
                        mapped.Add(new WorkOrderLineDto
                        {
                            PartId = part.Sparepartid,
                            PartName = part.Name,
                            Qty = line.Qty,
                            UnitPrice = part.Unitprice,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                    else
                    {
                        mapped.Add(new WorkOrderLineDto
                        {
                            PartId = line.PartId,
                            Qty = line.Qty,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                }
                dtoOut.Lines = mapped;
            }

            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Work Order updated");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error updating Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> SubmitAsync(Guid id, CancellationToken ct = default)
    {
        try
        {
            var entity = await LoadTrackedAsync(id, ct);
            if (entity == null) return ServiceResult<WorkOrderDto>.Failure("Work Order not found");

            if (!EditableStates.Contains(entity.Status ?? string.Empty))
            {
                return ServiceResult<WorkOrderDto>.Failure("Only DRAFT or REVISED Work Orders can be submitted");
            }

            entity.Status = "PENDING_CUSTOMER_DECISION";
            entity.Updatedat = DateTime.UtcNow;
            await _unitOfWork.SaveChangesAsync(ct);

            var dtoOut = (await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct) ?? entity).ToDto();
            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Submitted for approval");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error submitting Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> ApproveAsync(Guid id, ApproveWorkOrderDto dto, Guid approvedBy, CancellationToken ct = default)
    {
        try
        {
            var entity = await LoadTrackedAsync(id, ct);
            if (entity == null) return ServiceResult<WorkOrderDto>.Failure("Work Order not found");

            if (!string.Equals(entity.Status, "PENDING_CUSTOMER_DECISION", StringComparison.OrdinalIgnoreCase))
            {
                return ServiceResult<WorkOrderDto>.Failure("Only PENDING_CUSTOMER_DECISION Work Orders can be approved");
            }

            entity.Status = "APPROVED";
            entity.Approvedby = approvedBy;
            entity.Approvedat = DateTime.UtcNow;
            entity.Updatedat = entity.Approvedat;
            if (!string.IsNullOrWhiteSpace(dto.Note))
            {
                entity.Note = dto.Note;
            }

            await _unitOfWork.SaveChangesAsync(ct);

            var dtoOut = (await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct) ?? entity).ToDto();
            if (dtoOut != null)
            {
                dtoOut.ApprovedBy = approvedBy;
            }
            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Work Order approved");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error approving Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> RejectAsync(Guid id, RejectWorkOrderDto dto, CancellationToken ct = default)
    {
        try
        {
            if (string.IsNullOrWhiteSpace(dto.Reason))
            {
                return ServiceResult<WorkOrderDto>.Failure("Reject reason is required");
            }

            var entity = await LoadTrackedAsync(id, ct);
            if (entity == null) return ServiceResult<WorkOrderDto>.Failure("Work Order not found");

            if (!string.Equals(entity.Status, "PENDING_CUSTOMER_DECISION", StringComparison.OrdinalIgnoreCase))
            {
                return ServiceResult<WorkOrderDto>.Failure("Only PENDING_CUSTOMER_DECISION Work Orders can be rejected");
            }

            entity.Status = "REJECTED";
            entity.Note = dto.Reason; // Using Note to store reason (no dedicated field)
            entity.Updatedat = DateTime.UtcNow;

            await _unitOfWork.SaveChangesAsync(ct);

            var dtoOut = (await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct) ?? entity).ToDto();
            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Work Order rejected");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error rejecting Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> ReviseAsync(Guid id, ReviseWorkOrderDto dto, CancellationToken ct = default)
    {
        try
        {
            var entity = await LoadTrackedAsync(id, ct);
            if (entity == null) return ServiceResult<WorkOrderDto>.Failure("Work Order not found");

            if (!string.Equals(entity.Status, "REJECTED", StringComparison.OrdinalIgnoreCase))
            {
                return ServiceResult<WorkOrderDto>.Failure("Only REJECTED Work Orders can be revised");
            }

            entity.Status = "REVISED";
            entity.UpdateFromDto(dto.Payload);
            await _unitOfWork.SaveChangesAsync(ct);

            var refreshed = await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct) ?? entity;
            var dtoOut = refreshed.ToDto();
            dtoOut.Title = dto.Payload.Title;
            dtoOut.Description = dto.Payload.Description;
            dtoOut.EstimatedAmount = dto.Payload.EstimatedAmount;
            if (dto.Payload.Lines != null && dto.Payload.Lines.Any())
            {
                var mapped = new List<WorkOrderLineDto>();
                foreach (var line in dto.Payload.Lines)
                {
                    var partObj = await _unitOfWork.SparepartRepository.GetByIdAsync(line.PartId);
                    if (partObj is SparepartTuht part)
                    {
                        mapped.Add(new WorkOrderLineDto
                        {
                            PartId = part.Sparepartid,
                            PartName = part.Name,
                            Qty = line.Qty,
                            UnitPrice = part.Unitprice,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                    else
                    {
                        mapped.Add(new WorkOrderLineDto
                        {
                            PartId = line.PartId,
                            Qty = line.Qty,
                            LaborCode = line.LaborCode,
                            LaborHours = line.LaborHours
                        });
                    }
                }
                dtoOut.Lines = mapped;
            }

            return ServiceResult<WorkOrderDto>.Success(dtoOut, "Work Order revised");
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error revising Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<WorkOrderDto>> GetByIdAsync(Guid id, CancellationToken ct = default)
    {
        try
        {
            var entity = await _unitOfWork.WorkOrderRepository.GetByIdAsync(id, ct);
            if (entity == null) return ServiceResult<WorkOrderDto>.Failure("Work Order not found");
            var dto = entity.ToDto();
            // Join checklist summary by IntakeId
            if (dto.IntakeId != Guid.Empty)
            {
                var checklist = await _unitOfWork.ChecklistRepository.GetResponsesAsync(dto.IntakeId, ct);
                dto.ChecklistSummary = checklist.Select(x => new ChecklistSummaryDto
                {
                    ItemName = x.Item?.Name ?? "Unknown Item",
                    Severity = x.Severity,
                    Comment = x.Comment,
                    PhotoUrl = x.Photourl
                }).ToList();
            }
            return ServiceResult<WorkOrderDto>.Success(dto);
        }
        catch (Exception ex)
        {
            return ServiceResult<WorkOrderDto>.Failure($"Error retrieving Work Order: {ex.Message}");
        }
    }

    public async Task<IServiceResult<List<WorkOrderDto>>> GetRangeAsync(Guid? centerId, DateOnly? date, string? status, Guid? technicianId, CancellationToken ct = default)
    {
        try
        {
            var entities = await _unitOfWork.WorkOrderRepository.GetRangeAsync(centerId, date, status, technicianId, ct);
            var dtos = entities.ToDto();
            // Enrich with checklist summaries for each item
            foreach (var dto in dtos)
            {
                if (dto.IntakeId != Guid.Empty)
                {
                    var checklist = await _unitOfWork.ChecklistRepository.GetResponsesAsync(dto.IntakeId, ct);
                    dto.ChecklistSummary = checklist.Select(x => new ChecklistSummaryDto
                    {
                        ItemName = x.Item?.Name ?? "Unknown Item",
                        Severity = x.Severity,
                        Comment = x.Comment,
                        PhotoUrl = x.Photourl
                    }).ToList();
                }
            }
            return ServiceResult<List<WorkOrderDto>>.Success(dtos);
        }
        catch (Exception ex)
        {
            return ServiceResult<List<WorkOrderDto>>.Failure($"Error retrieving Work Orders: {ex.Message}");
        }
    }

    public async Task<IServiceResult<List<WorkOrderDto>>> GetMyWorkOrdersAsync(Guid currentUserId, string role, CancellationToken ct)
    {
        try
        {
            var query = _unitOfWork.WorkOrderRepository
                .GetAllQueryable()
                .Include(wo => wo.Order)
                    .ThenInclude(o => o.Booking)
                        .ThenInclude(b => b.Serviceintakethaontt)
                .AsNoTracking();

            if (string.Equals(role, "TECHNICIAN", StringComparison.OrdinalIgnoreCase))
            {
                query = query.Where(x => x.Order.Booking != null && x.Order.Booking.Serviceintakethaontt != null && x.Order.Booking.Serviceintakethaontt.CheckedInBy == currentUserId);
            }
            else if (string.Equals(role, "CUSTOMER", StringComparison.OrdinalIgnoreCase))
            {
                query = query.Where(x => x.Order.Booking != null && x.Order.Booking.Customerid == currentUserId);
            }

            var list = await query
                .OrderByDescending(x => x.Createdat)
                .ToListAsync(ct);

            var dtos = new List<WorkOrderDto>();
            foreach (var entity in list)
            {
                var dto = entity.ToDto();
                if (dto.IntakeId != Guid.Empty)
                {
                    var checklist = await _unitOfWork.ChecklistRepository.GetResponsesAsync(dto.IntakeId, ct);
                    dto.ChecklistSummary = checklist.Select(x => new ChecklistSummaryDto
                    {
                        ItemName = x.Item?.Name ?? "Unknown Item",
                        Severity = x.Severity,
                        Comment = x.Comment,
                        PhotoUrl = x.Photourl
                    }).ToList();
                }
                dtos.Add(dto);
            }

            return ServiceResult<List<WorkOrderDto>>.Success(dtos);
        }
        catch (Exception ex)
        {
            return ServiceResult<List<WorkOrderDto>>.Failure($"Error retrieving user Work Orders: {ex.Message}");
        }
    }

    private async Task<Workorderapprovalthaontt?> LoadTrackedAsync(Guid id, CancellationToken ct)
    {
        return await _unitOfWork.WorkOrderRepository
            .GetAllQueryable()
            .Include(wo => wo.Order)
                .ThenInclude(o => o.Booking)
                    .ThenInclude(b => b.Serviceintakethaontt)
            .FirstOrDefaultAsync(wo => wo.WoaId == id, ct);
    }
}
